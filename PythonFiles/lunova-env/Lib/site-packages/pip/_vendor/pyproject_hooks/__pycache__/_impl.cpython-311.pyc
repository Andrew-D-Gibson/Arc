打开文档<if(COMMANDLINEARGUMENTS&&PROCESSID)>运行应用程序 <APPLICATIONPATH> (带参数 <COMMANDLINEARGUMENTS>)，将其进程 ID 存储到 <PROCESSID> 中<elseif(PROCESSID)>运行应用程序 <APPLICATIONPATH>，将其进程 ID 存储到 <PROCESSID> 中<elseif(COMMANDLINEARGUMENTS)>运行应用程序 <APPLICATIONPATH> (带参数 <COMMANDLINEARGUMENTS>)<else>运行应用程序 <APPLICATIONPATH><endif>z在不可见模式下运行 DOS 命令或控制台应用程序，完成时检索其输出，并在分配的时间后失败
<if(STANDARDOUTPUT&&STANDARDERROR&&EXITCODE)>运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，将其错误存储到 <STANDARDERROR> 中，将其退出代码存储到 <EXITCODE> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDOUTPUT&&STANDARDERROR)>
运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，将其错误存储到 <STANDARDERROR> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDOUTPUT&&EXITCODE)>
运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，将其退出代码存储到 <EXITCODE> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDERROR&&EXITCODE)>
运行 DOS 命令或控制台应用程序，将其错误存储到 <STANDARDERROR> 中，将其退出代码存储到 <EXITCODE> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDOUTPUT)>
运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDERROR)>
运行 DOS 命令或控制台应用程序，将其错误存储到 <STANDARDERROR> 中，并在 <TIMEOUT> 秒后失败<elseif(EXITCODE)>
运行 DOS 命令或控制台应用程序，将其退出代码存储到 <EXITCODE> 中，并在 <TIMEOUT> 秒后失败<else>
运行 DOS 命令或控制台应用程序，并在 <TIMEOUT> 秒后失败<endif>在不可见模式下运行 DOS 命令或控制台应用程序，完成时使用不同的代码页检索其输出，并在分配的时间后失败
<if(STANDARDOUTPUT&&STANDARDERROR&&EXITCODE)>运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，将其错误存储到 <STANDARDERROR> 中，将其退出代码存储到 <EXITCODE> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDOUTPUT&&STANDARDERROR)>
运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，将其错误存储到 <STANDARDERROR> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDOUTPUT&&EXITCODE)>
运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，将其退出代码存储到 <EXITCODE> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDERROR&&EXITCODE)>
运行 DOS 命令或控制台应用程序，将其错误存储到 <STANDARDERROR> 中，将其退出代码存储到 <EXITCODE> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDOUTPUT)>
运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，并在 <TIMEOUT> 秒后失败<elseif(STANDARDERROR)>
运行 DOS 命令或控制台应用程序，将其错误存储到 <STANDARDERROR> 中，并在 <TIMEOUT> 秒后失败<elseif(EXITCODE)>
运行 DOS 命令或控制台应用程序，将其退出代码存储到 <EXITCODE> 中，并在 <TIMEOUT> 秒后失败<else>
运行 DOS 命令或控制台应用程序，并在 <TIMEOUT> 秒后失败<endif>t在不可见模式下运行 DOS 命令或控制台应用程序，并在完成时使用其他代码页检索其输出<if(STANDARDOUTPUT&&STANDARDERROR&&EXITCODE)>运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，将其错误存储到 <STANDARDERROR> 中，并将其退出代码存储到 <EXITCODE> 中<elseif(STANDARDOUTPUT&&STANDARDERROR)>运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，并将其错误存储到 <STANDARDERROR> 中<elseif(STANDARDOUTPUT&&EXITCODE)>运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，并将其退出代码存储到 <EXITCODE> 中<elseif(STANDARDERROR&&EXITCODE)>运行 DOS 命令或控制台应用程序，将其错误存储到 <STANDARDERROR> 中，并将其退出代码存储到 <EXITCODE> 中<elseif(STANDARDOUTPUT)>运行 DOS 命令或控制台应用程序，并将其输出存储到 <STANDARDOUTPUT> 中<elseif(STANDARDERROR)>运行 DOS 命令或控制台应用程序，并将其错误存储到 <STANDARDERROR> 中<elseif(EXITCODE)>运行 DOS 命令或控制台应用程序，并将其退出代码存储到 <EXITCODE> 中<else>运行 DOS 命令或控制台应用程序<endif>_在不可见模式下运行 DOS 命令或控制台应用程序，并在完成时检索其输出<if(STANDARDOUTPUT&&STANDARDERROR&&EXITCODE)>运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，将其错误存储到 <STANDARDERROR> 中，并将其退出代码存储到 <EXITCODE> 中<elseif(STANDARDOUTPUT&&STANDARDERROR)>运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，并将其错误存储到 <STANDARDERROR> 中<elseif(STANDARDOUTPUT&&EXITCODE)>运行 DOS 命令或控制台应用程序，将其输出存储到 <STANDARDOUTPUT> 中，并将其退出代码存储到 <EXITCODE> 中<elseif(STANDARDERROR&&EXITCODE)>运行 DOS 命令或控制台应用程序，将其错误存储到 <STANDARDERROR> 中，并将其退出代码存储到 <EXITCODE> 中<elseif(STANDARDOUTPUT)>运行 DOS 命令或控制台应用程序，并将其输出存储到 <STANDARDOUTPUT> 中<elseif(STANDARDERROR)>运行 DOS 命令或控制台应用程序，并将其错误存储到 <STANDARDERROR> 中<elseif(EXITCODE)>运行 DOS 命令或控制台应用程序，并将其退出代码存储到 <EXITCODE> 中<else>运行 DOS 命令或控制台应用程序<endif>*指定是否更改会话的当前代码页更改代码页EDOS 命令的名称或控制台应用程序(带参数，如果适用)DOS 命令或应用程序_在不可见模式下运行 DOS 命令或控制台应用程序，并在完成时检索其输出!读取输出时要使用的编码编码?命令或应用程序退出代码。此代码将为一个数值退出代码_指定 DOS 命令或应用程序是无限期运行还是在经过设置的一段时间后失败超时后失败运行 DOS 命令X描述在执行 DOS 命令或应用程序的过程中所出现错误的文本(如果有)标准错误(DOS 命令或应用程序的文本输出标准输出5等待脚本完成的最大秒数(-1 表示无限期)超时2要使用的文件夹的完整路径(如果适用)工作文件夹E执行用户提供的 .NET 脚本并将其输出存储在变量中。运行 .NET 脚本*要包含在脚本中的 .NET 脚本导入.NET 脚本导入脚本的语言语言9.NET 动态链接库(.dll 文件)引用所在的根路径要加载的引用请确保选择包含您尝试执行的脚本的程序集(.dll)依赖项的适当文件夹路径，检查目标文件夹中是否包含所有程序集(.dll)依赖项。要运行的 .NET 代码要运行的 .NET 代码运行 .NET 脚本6运行 Javascript 脚本并在分配的时间后失败<if(SCRIPTOUTPUT&&SCRIPTERROR)>运行 JavaScript 脚本，将其输出存储到 <SCRIPTOUTPUT> 中，将其错误存储到 <SCRIPTERROR> 中，并在 <TIMEOUT> 秒后失败<elseif(SCRIPTOUTPUT)>
运行 JavaScript 脚本，将其输出存储到 <SCRIPTOUTPUT> 中，并在 <TIMEOUT> 秒后失败<elseif(SCRIPTERROR)>
运行 JavaScript 脚本，将其错误存储到 <SCRIPTERROR> 中，并在 <TIMEOUT> 秒后失败<else>
运行 JavaScript 脚本，并在 <TIMEOUT> 秒后失败<endif>H执行某些自定义 JavaScript 代码并将其输出存储到变量中W指定 JavaScript 脚本是无限期运行还是在经过设置的一段时间后失败超时后失败运行 JavaScript~要执行的 JavaScript 代码。可以在脚本中包含变量，因为它们将在执行 JavaScript 代码之前进行评估要运行的 JavaScript6执行 JavaScript 代码期间可能会出现的错误错误输出脚本的输出输出<if(SCRIPTOUTPUT&&SCRIPTERROR)>运行 JavaScript 并将其输出存储到 <SCRIPTOUTPUT> 中，将其错误存储到 <SCRIPTERROR> 中<elseif(SCRIPTOUTPUT)>
运行 JavaScript 并将其输出存储到 <SCRIPTOUTPUT> 中<elseif(SCRIPTERROR)>
运行 JavaScript 并将其错误存储到 <SCRIPTERROR> 中<else>
运行 JavaScript<endif>5等待脚本完成的最大秒数(-1 表示无限期)超时6运行 Powershell 脚本并在分配的时间后失败<if(SCRIPTOUTPUT&&SCRIPTERROR)>运行 PowerShell 脚本，将其输出存储到 <SCRIPTOUTPUT> 中，将其错误存储到 <SCRIPTERROR> 中，并在 <TIMEOUT> 秒后失败<elseif(SCRIPTOUTPUT)>
运行 PowerShell 脚本，将其输出存储到 <SCRIPTOUTPUT> 中，并在 <TIMEOUT> 秒后失败<elseif(SCRIPTERROR)>
运行 PowerShell 脚本，将其错误存储到 <SCRIPTERROR> 中，并在 <TIMEOUT> 秒后失败<else>
运行 PowerShell 脚本，并在 <TIMEOUT> 秒后失败<endif>H执行某些自定义 PowerShell 脚本并将其输出存储到变量中W指定 PowerShell 脚本是无限期运行还是在经过设置的一段时间后失败超时后失败运行 PowerShell 脚本6执行 PowerShell 代码期间可能会出现的错误错误脚本的输出输出~要执行的 PowerShell 代码。可以在脚本中包含变量，因为它们将在执行 PowerShell 代码之前进行评估要运行的 PowerShell 代码<if(SCRIPTOUTPUT&&SCRIPTERROR)>运行 PowerShell 脚本并将其输出存储到 <SCRIPTOUTPUT> 中，将其错误存储到 <SCRIPTERROR> 中<elseif(SCRIPTOUTPUT)>
运行 PowerShell 脚本并将其输出存储到 <SCRIPTOUTPUT> 中<elseif(SCRIPTERROR)>
运行 PowerShell 脚本并将其错误存储到 <SCRIPTERROR> 中<else>
运行 PowerShell 脚本<endif>5等待脚本完成的最大秒数(-1 表示无限期)超时.执行 Python 2 脚本代码并检索其输出运行 Python 脚本/外部 Python 模块所在的文件夹的路径模块文件夹路径 要执行的 Python 脚本代码要运行的 Python 脚本8执行 Python 脚本代码期间可能会出现的错误错误输出脚本的输出输出<if(SCRIPTOUTPUT&&SCRIPTERROR)>运行 Python 脚本 <PYTHONCODE> 并将其输出存储到 <SCRIPTOUTPUT> 中，将其错误存储到 <SCRIPTERROR> 中<elseif(SCRIPTOUTPUT)>
运行 Python 脚本 <PYTHONCODE> 并将其输出存储到 <SCRIPTOUTPUT> 中<elseif(SCRIPTERROR)>
运行 Python 脚本 <PYTHONCODE> 并将其错误存储到 <SCRIPTERROR> 中<else>
运行 Python 脚本<PYTHONCODE><endif>4运行 VBScript 脚本并在分配的时间后失败<if(SCRIPTOUTPUT&&SCRIPTERROR)>运行 VBScript 脚本，将其输出存储到 <SCRIPTOUTPUT> 中，将其错误存储到 <SCRIPTERROR> 中，并在 <TIMEOUT> 秒后失败<elseif(SCRIPTOUTPUT)>
运行 VBScript 脚本，将其输出存储到 <SCRIPTOUTPUT> 中，并在 <TIMEOUT> 秒后失败<elseif(SCRIPTERROR)>
运行 VBScript 脚本，将其错误存储到 <SCRIPTERROR> 中，并在 <TIMEOUT> 秒后失败<else>
运行 VBScript 脚本，并在 <TIMEOUT> 秒后失败<endif>F执行某些自定义 VBScript 代码并将其输出存储到变量中U指定 VBScript 脚本是无限期运行还是在经过设置的一段时间后失败超时后失败运行 VBScript4执行 VBScript 代码期间可能会出现的错误错误脚本的输出输出<if(SCRIPTOUTPUT&&SCRIPTERROR)>运行 VBScript 并将其输出存储到 <SCRIPTOUTPUT> 中，将其错误存储到 <SCRIPTERROR> 中<elseif(SCRIPTOUTPUT)>
运行 VBScript 并将其输出存储到 <SCRIPTOUTPUT> 中<elseif(SCRIPTERROR)>
运行 VBScript 并将其错误存储到 <SCRIPTERROR> 中<else>
运行 VBScript<endif>5等待脚本完成的最大秒数(-1 表示无限期)超时t要执行的 VBScript 代码。可以在脚本中包含变量，因为它们将在执行 VBScript 之前进行评估要运行的 VBScript所有屏幕前景窗口	主屏幕选择屏幕禁用启用启动停止$将打印机设置为默认打印机设置默认打印机-要设置为默认打印机的打印机名称打印机名称*将 <PRINTERNAME> 设置为默认打印机!将环境变量设置为给定值设置 Windows 环境变量环境变量的名称环境变量名称/将值 <VALUE> 设置到环境变量 <NAME> 中环境变量的类型类型要设置到环境变量的值新的环境变量值<设置所选监视器的宽度、高度、位计数和频率设置屏幕分辨率'要将监视器位计数设置到的值监视器位计数$要将监视器频率设置到的值监视器频率$要将监视器高度设置到的值监视器高度*要设置其分辨率的监视器的编号监视器编号$要将监视器宽度设置到的值监视器宽度2设置监视器 <MONITORNUMBER> 的屏幕分辨率显示桌面c指定是否最小化所有窗口以显示桌面，或将所有窗口还原到其各自原始状态操作显示桌面<DESKTOPOPERATION>	进程 ID进程名称	剪贴板文件星号	警告声	感叹号手形问号B在 Windows 环境中执行各种任务并从系统中检索信息系统<获取整个屏幕的屏幕截图并将其保存到文件中>获取整个屏幕的屏幕截图并将其保存到 <FILE> 中要捕获的区域捕获]获取前景窗口或指定屏幕的屏幕截图，并将图像保存到文件或剪贴板中<将在其中保存所捕获图像的文件名的完整路径图像文件获取屏幕截图!要保存的图像文件的格式图像格式指定要捕获的屏幕要捕获的屏幕$要将屏幕截图保存到的位置将屏幕截图保存到<获取前景窗口的屏幕截图并将其保存到文件中>获取前景窗口的屏幕截图并将其保存到 <FILE> 中?获取前景窗口的屏幕截图并将其保存到剪贴板中?获取前景窗口的屏幕截图并将其保存到剪贴板中9获取主屏幕的屏幕截图并将其保存到文件中;获取主屏幕的屏幕截图并将其保存到 <FILE> 中<获取主屏幕的屏幕截图并将其保存到剪贴板中<获取主屏幕的屏幕截图并将其保存到剪贴板中?获取所指定屏幕的屏幕截图并将其保存到文件中K获取屏幕 <SCREENTOCAPTURE> 的屏幕截图并将其保存到 <FILE> 中B获取所指定屏幕的屏幕截图并将其保存到剪贴板中I获取屏幕 <SCREENTOCAPTURE> 的屏幕截图并将其保存到剪贴中?获取所有屏幕的屏幕截图并将其保存到剪贴板中?获取整个屏幕的屏幕截图并将其保存到剪贴板中+根据 ID 立即停止正在运行的进程#终止 ID 为 <PROCESSID> 的进程-根据名称立即停止正在运行的进程-终止名称为 <PROCESSNAME> 的所有进程!立即停止正在运行的进程终止进程要终止的进程的 ID	进程 IDc要终止的进程的名称。如果正在运行多个同名的进程，则它们将会全部终止进程名称=指定将按其名称还是其 ID 来指定要终止的进程指定进程的依据'在自动化中集成脚本语言代码脚本!在工作站上执行各种任务	工作站立即继续等待应用程序完成等待应用程序加载启动停止3指定是一直等到某个进程启动还是停止等待进程!等待进程 <PROCESSNAME> 启动!等待进程 <PROCESSNAME> 停止'挂起执行直至进程启动或停止等待进程 BSJB         v4.0.30319     l     #~  t    #Strings    @     #US H     #GUID   X    #Blob           	   %3                                    %   B   _   x                      	 <   <   <  ! <  ) <  1 <  9 <  .   .   .  	. # . + ,. 3 <. ; {           $ /k            
   
        s       <Module> mscorlib System.Reflection AssemblyTitleAttribute .ctor AssemblyDescriptionAttribute AssemblyCompanyAttribute AssemblyProductAttribute AssemblyInformationalVersionAttribute AssemblyCopyrightAttribute AssemblyFileVersionAttribute Microsoft.Flow.RPA.Desktop.Modules.System.Actions.resources.dll Microsoft.Flow.RPA.Desktop.Modules.System.Actions.resources zh-Hans Microsoft.Flow.RPA.Desktop.Modules.System.Actions.Properties.Resources.zh-Hans.resources        $a6d\L(Pn]  z\V4ȍhCO3ST  $          $  RSA1     gw:މ8e `Y>Ēe??13`!g-1/%}oY5L9EC;&=oGP\dEk*+Ge+] System  6 1Microsoft.Flow.RPA.Desktop.Modules.System.Actions   	Microsoft   Power Automate   
1.