       Instr("LOAD_CONST", 5),
                Instr("BUILD_LIST", 3),
                Instr("UNPACK_SEQUENCE", 3),
                Instr("STORE_NAME", "x"),
                Instr("STORE_NAME", "y"),
                Instr("STORE_NAME", "z"),
            ]
        )
        self.check(
            code,
            Instr("LOAD_CONST", 5),
            Instr("LOAD_CONST", 4),
            Instr("LOAD_CONST", 3),
            Instr("STORE_NAME", "x"),
            Instr("STORE_NAME", "y"),
            Instr("STORE_NAME", "z"),
        )

    def test_build_set(self):
        # test = x in {1, 2, 3}
        code = Bytecode(
            [
                Instr("LOAD_NAME", "x"),
                Instr("LOAD_CONST", 1),
                Instr("LOAD_CONST", 2),
                Instr("LOAD_CONST", 3),
                Instr("BUILD_SET", 3),
                Instr("COMPARE_OP", Compare.IN),
                Instr("STORE_NAME", "test"),
            ]
        )

        self.check(
            code,
            Instr("LOAD_NAME", "x"),
            Instr("LOAD_CONST", frozenset((1, 2, 3))),
            Instr("COMPARE_OP", Compare.IN),
            Instr("STORE_NAME", "test"),
        )

    def test_compare_op_unary_not(self):
        for op, not_op in (
            (Compare.IN, Compare.NOT_IN),  # in => not in
            (Compare.NOT_IN, Compare.IN),  # not in => in
            (Compare.IS, Compare.IS_NOT),  # is => is not
            (Compare.IS_NOT, Compare.IS),  # is not => is
        ):
            code = Bytecode(
                [
                    Instr("LOAD_NAME", "a"),
                    Instr("LOAD_NAME", "b"),
                    Instr("COMPARE_OP", op),
                    Instr("UNARY_NOT"),
                    Instr("STORE_NAME", "x"),
                ]
            )
            self.check(
                code,
                Instr("LOAD_NAME", "a"),
                Instr("LOAD_NAME", "b"),
                Instr("COMPARE_OP", not_op),
                Instr("STORE_NAME", "x"),
            )

        # don't optimize:
        # x = not (a and b is True)
        label_instr5 = Label()
        code = Bytecode(
            [
                Instr("LOAD_NAME", "a"),
                Instr("JUMP_IF_FALSE_OR_POP", label_instr5),
                Instr("LOAD_NAME", "b"),
                Instr("LOAD_CONST", True),
                Instr("COMPARE_OP", Compare.IS),
                label_instr5,
                Instr("UNARY_NOT"),
                Instr("STORE_NAME", "x"),
                Instr("LOAD_CONST", None),
                Instr("RETURN_VALUE"),
            ]
        )
        self.check_dont_optimize(code)

    def test_dont_optimize(self):
        # x = 3 < 5
        code = Bytecode(
            [
                Instr("LOAD_CONST", 3),
                Instr("LOAD_CONST", 5),
                Instr("COMPARE_OP", Compare.LT),
                Instr("STORE_NAME", "x"),
                Instr("LOAD_CONST", None),
                Instr("RETURN_VALUE"),
            ]
        )
        self.check_dont_optimize(code)

        # x = (10, 20, 30)[1:]
        code = Bytecode(
            [
                Instr("LOAD_CONST", (10, 20, 30)),
                Instr("LOAD_CONST", 1),
                Instr("LOAD_CONST", None),
                Instr("BUILD_SLICE", 2),
                Instr("BINARY_SUBSCR"),
                Instr("STORE_NAME", "x"),
            ]
        )
        self.check_dont_optimize(code)

    def test_optimize_code_obj(self):
        # Test optimize() method with a code object
        #
        # x = 3 + 5 => x = 8
        noopt = Bytecode(
            [
                Instr("LOAD_CONST", 3),
                Instr("LOAD_CONST", 5),
                Instr("BINARY_ADD"),
                Instr("STORE_NAME", "x"),
                Instr("LOAD_CONST", None),
                Instr("RETURN_VALUE"),
            ]
        )
        noopt = noopt.to_code()

        optimizer = peephole_opt.PeepholeOptimizer()
        optim = optimizer.optimize(noopt)

        code = Bytecode.from_code(optim)
        self.assertEqual(
            code,
            [
                Instr("LOAD_CONST", 8, lineno=1),
                Instr("STORE_NAME", "x", lineno=1),
                Instr("LOAD_CONST", None, lineno=1),
                Instr("RETURN_VALUE", lineno=1),
            ],
        )

    def test_return_value(self):
        # return+return: remove second return
        #
        #     def func():
        #         return 4
        #         return 5
        code = Bytecode(
            [
                Instr("LOAD_CONST", 4, lineno=2),
                Instr("RETURN_VALUE", lineno=2),
                Instr("LOAD_CONST", 5, lineno=3),
                Instr("RETURN_VALUE", lineno=3),
            ]
        )
        code = ControlFlowGraph.from_bytecode(code)
        self.check(
            code, Instr("LOAD_CONST", 4, lineno=2), Instr("RETURN_VALUE", lineno=2)
        )

        # return+return + return+return: remove second and fourth return
        #
        #     def func():
        #         return 4
        #         return 5
        #         return 6
        #         return 7
        code = Bytecode(
            [
                Instr("LOAD_CONST", 4, lineno=2),
                Instr("RETURN_VALUE", lineno=2),
                Instr("LOAD_CONST", 5, lineno=3),
                Instr("RETURN_VALUE", lineno=3),
                Instr("LOAD_CONST", 6, lineno=4),
                Instr("RETURN_VALUE", lineno=4),
                Instr("LOAD_CONST", 7, lineno=5),
                Instr("RETURN_VALUE", lineno=5),
            ]
        )
        code = ControlFlowGraph.from_bytecode(code)
        self.check(
            code, Instr("LOAD_CONST", 4, lineno=2), Instr("RETURN_VALUE", lineno=2)
        )

        # return + JUMP_ABSOLUTE: remove JUMP_ABSOLUTE
        # while 1:
        #     return 7
        if sys.version_info < (3, 8):
            setup_loop = Label()
            return_label = Label()
            code = Bytecode(
                [
                    setup_loop,
                    Instr("SETUP_LOOP", return_