define(["require", "exports", "tslib", "react", "../../common/DirectionalHint", "../../Utilities", "../../Positioning", "../../Popup", "../../Utilities", "../../Styling", "@fluentui/react-hooks"], function (require, exports, tslib_1, React, DirectionalHint_1, Utilities_1, Positioning_1, Popup_1, Utilities_2, Styling_1, react_hooks_1) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    var ANIMATIONS = (_a = {},
        _a[Positioning_1.RectangleEdge.top] = Styling_1.AnimationClassNames.slideUpIn10,
        _a[Positioning_1.RectangleEdge.bottom] = Styling_1.AnimationClassNames.slideDownIn10,
        _a[Positioning_1.RectangleEdge.left] = Styling_1.AnimationClassNames.slideLeftIn10,
        _a[Positioning_1.RectangleEdge.right] = Styling_1.AnimationClassNames.slideRightIn10,
        _a);
    var getClassNames = Utilities_2.classNamesFunction({
        disableCaching: true,
    });
    var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
    // Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.
    // To help ensure that edge will respect the offscreen style opacity
    // filter needs to be added as an additional way to set opacity.
    // Also set pointer-events: none so that the callout will not occlude the element it is
    // going to be positioned against
    var OFF_SCREEN_STYLE = { opacity: 0, filter: 'opacity(0)', pointerEvents: 'none' };
    // role and role description go hand-in-hand. Both would be included by spreading getNativeProps for a basic element
    // This constant array can be used to filter these out of native props spread on callout root and apply them together on
    // calloutMain (the Popup component within the callout)
    var ARIA_ROLE_ATTRIBUTES = ['role', 'aria-roledescription'];
    var DEFAULT_PROPS = {
        preventDismissOnLostFocus: false,
        preventDismissOnScroll: false,
        preventDismissOnResize: false,
        isBeakVisible: true,
        beakWidth: 16,
        gapSpace: 0,
        minPagePadding: 8,
        directionalHint: DirectionalHint_1.DirectionalHint.bottomAutoEdge,
    };
    /**
     * Returns a function to lazily fetch the bounds of the target element for the callout
     */
    function useBounds(_a, targetRef, targetWindow) {
        var bounds = _a.bounds, _b = _a.minPagePadding, minPagePadding = _b === void 0 ? DEFAULT_PROPS.minPagePadding : _b, target = _a.target;
        var cachedBounds = React.useRef();
        var getBounds = React.useCallback(function () {
            if (!cachedBounds.current) {
                var currentBounds = typeof bounds === 'function' ? (targetWindow ? bounds(target, targetWindow) : undefined) : bounds;
                if (!currentBounds && targetWindow) {
                    currentBounds = Positioning_1.getBoundsFromTargetWindow(targetRef.current, targetWindow);
                    currentBounds = {
                        top: currentBounds.top + minPagePadding,
                        left: currentBounds.left + minPagePadding,
                        right: currentBounds.right - minPagePadding,
                        bottom: currentBounds.bottom - minPagePadding,
                        width: currentBounds.width - minPagePadding * 2,
                        height: currentBounds.height - minPagePadding * 2,
                    };
                }
                cachedBounds.current = currentBounds;
            }
            return cachedBounds.current;
        }, [bounds, minPagePadding, target, targetRef, targetWindow]);
        return getBounds;
    }
    /**
     * Returns the maximum available height for the Callout to render into
     */
    function useMaxHeight(_a, targetRef, getBounds) {
        var beakWidth = _a.beakWidth, coverTarget = _a.coverTarget, directionalHint = _a.directionalHint, directionalHintFixed = _a.directionalHintFixed, gapSpace = _a.gapSpace, isBeakVisible = _a.isBeakVisible, hidden = _a.hidden;
        var _b = React.useState(), maxHeight = _b[0], setMaxHeight = _b[1];
        var async = react_hooks_1.useAsync();
        // Updating targetRef won't re-render the component, but it's recalculated (if needed) with every render
        // If it mutates, we want to re-run the effect
        var currentTarget = targetRef.current;
        React.useEffect(function () {
            var _a;
            if (!maxHeight && !hidden) {
                if (directionalHintFixed && currentTarget) {
                    // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will
                    // overlap with the target.
                    var totalGap_1 = ((gapSpace !== null && gapSpace !== void 0 ? gapSpace : 0)) + (isBeakVisible && beakWidth ? beakWidth : 0);
                    async.requestAnimationFrame(function () {
                        if (targetRef.current) {
                            setMaxHeight(Positioning_1.getMaxHeight(targetRef.current, directionalHint, totalGap_1, getBounds(), coverTarget));
                        }
                    });
                }
                else {
                    setMaxHeight((_a = getBounds()) === null || _a === void 0 ? void 0 : _a.height);
                }
            }
            else if (hidden) {
                setMaxHeight(undefined);
            }
        }, [
            targetRef,
            currentTarget,
            gapSpace,
            beakWidth,
            getBounds,
            hidden,
            async,
            coverTarget,
            directionalHint,
            directionalHintFixed,
            isBeakVisible,
            maxHeight,
        ]);
        return maxHeight;
    }
    /**
     * Returns the height offset of the callout element and updates it each frame to approach the configured finalHeight
     */
    function useHeightOffset(_a, calloutElement) {
        var fin