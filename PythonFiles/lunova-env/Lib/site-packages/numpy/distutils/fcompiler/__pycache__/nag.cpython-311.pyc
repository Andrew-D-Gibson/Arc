int;
        React.useEffect(function () {
            if (!hidden) {
                var timerId_1 = async.requestAnimationFrame(function () {
                    var _a;
                    // If we expect a target element to position against, we need to wait until `targetRef.current`
                    // is resolved. Otherwise we can try to position.
                    var expectsTarget = !!target;
                    if (hostElement.current && calloutElement.current && (!expectsTarget || targetRef.current)) {
                        var currentProps = tslib_1.__assign(tslib_1.__assign({}, props), { target: targetRef.current, bounds: getBounds() });
                        // If there is a finalHeight given then we assume that the user knows and will handle
                        // additional positioning adjustments so we should call positionCard
                        var newPositions = finalHeight
                            ? Positioning_1.positionCard(currentProps, hostElement.current, calloutElement.current, positions)
                            : Positioning_1.positionCallout(currentProps, hostElement.current, calloutElement.current, positions);
                        // Set the new position only when the positions are not exists or one of the new callout positions
                        // are different. The position should not change if the position is within 2 decimal places.
                        if ((!positions && newPositions) ||
                            (positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5)) {
                            // We should not reposition the callout more than a few times, if it is then the content is likely resizing
                            // and we should stop trying to reposition to prevent a stack overflow.
                            positionAttempts.current++;
                            setPositions(newPositions);
                        }
                        else if (positionAttempts.current > 0) {
                            // Only call the onPositioned callback if the callout has been re-positioned at least once.
                            positionAttempts.current = 0;
                            (_a = onPositioned) === null || _a === void 0 ? void 0 : _a(positions);
                        }
                    }
                }, calloutElement.current);
                return function () { return async.cancelAnimationFrame(timerId_1); };
            }
        }, [
            hidden,
            directionalHint,
            async,
            calloutElement,
            hostElement,
            targetRef,
            finalHeight,
            getBounds,
            onPositioned,
            positions,
            props,
            target,
        ]);
        return positions;
    }
    /**
     * Hook to set up behavior to automatically focus the callout when it appears, if indicated by props.
     */
    function useAutoFocus(_a, positions, calloutElement) {
        var hidden = _a.hidden, setInitialFocus = _a.setInitialFocus;
        var async = react_hooks_1.useAsync();
        var hasPositions = !!positions;
        React.useEffect(function () {
            if (!hidden && setInitialFocus && hasPositions && calloutElement.current) {
                var timerId_2 = async.requestAnimationFrame(function () { return Utilities_1.focusFirstChild(calloutElement.current); }, calloutElement.current);
                return function () { return async.cancelAnimationFrame(timerId_2); };
            }
        }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);
    }
    /**
     * Hook to set up various handlers to dismiss the popup when it loses focus or the window scrolls or similar cases.
     */
    function useDismissHandlers(_a, positions, hostElement, targetRef, targetWindow) {
        var hidden = _a.hidden, onDismiss = _a.onDismiss, 
        // eslint-disable-next-line deprecation/deprecation
        preventDismissOnScroll = _a.preventDismissOnScroll, 
        // eslint-disable-next-line deprecation/deprecation
        preventDismissOnResize = _a.preventDismissOnResize, 
        // eslint-disable-next-line deprecation/deprecation
        preventDismissOnLostFocus = _a.preventDismissOnLostFocus, shouldDismissOnWindowFocus = _a.shouldDismissOnWindowFocus, preventDismissOnEvent = _a.preventDismissOnEvent;
        var isMouseDownOnPopup = React.useRef(false);
        var async = react_hooks_1.useAsync();
        var mouseDownHandlers = react_hooks_1.useConst([
 