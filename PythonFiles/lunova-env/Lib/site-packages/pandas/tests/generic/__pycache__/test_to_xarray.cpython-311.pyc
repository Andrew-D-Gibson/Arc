 {\r\n                xuid: data_validation_1.asString(person.xuid),\r\n                gamertag: getGamertagForPerson(person),\r\n                realName: data_validation_1.asOptionalString(person.realName),\r\n                gamerscore: person.gamerScore ? Number.parseInt(person.gamerScore, 10) : undefined,\r\n                isIdentityShared: data_validation_1.asOptionalBool(person.isIdentityShared),\r\n                gamerpicUrl: data_validation_1.asOptionalString(person.displayPicRaw),\r\n                isXbox360Gamerpic: data_validation_1.asOptionalBool(person.isXbox360Gamerpic),\r\n                isFriend: data_validation_1.asOptionalBool(person.isFollowedByCaller),\r\n                isFollower: data_validation_1.asOptionalBool(person.isFollowingCaller),\r\n                followedDate: getFollowedDateForPerson(person),\r\n                isFavorite: data_validation_1.asOptionalBool(person.isFavorite),\r\n                isCloaked: data_validation_1.asOptionalBool(person.isCloaked),\r\n                isBroadcasting: data_validation_1.asOptionalBool(person.isBroadcasting),\r\n                linkedAccounts: getLinkedAccountsForPerson(person),\r\n                multiplayerSummary: requestedDecorations.includes(\"multiplayerSummary\")\r\n                    ? getMultiplayerSummaryForPerson(person, logger)\r\n                    : lce_1.lceNotRequested(),\r\n                preferredColors: requestedDecorations.includes(\"preferredColor\")\r\n                    ? getColorsForPerson(person)\r\n                    : lce_1.lceNotRequested(),\r\n                presence: requestedDecorations.includes(\"presenceDetail\")\r\n                    ? getPresenceForPerson(person)\r\n                    : lce_1.lceNotRequested(),\r\n                detail: requestedDecorations.includes(\"detail\") ? getDetailForPerson(person) : lce_1.lceNotRequested(),\r\n                recentPlayerInfo: requestedDecorations.includes(\"recentPlayer\")\r\n                    ? getRecentPlayerInfoForPerson(person)\r\n                    : lce_1.lceNotRequested(),\r\n                recommendation: requestedDecorations.includes(\"recommendation\")\r\n                    ? getRecommendationInfoForPerson(person)\r\n                    : lce_1.lceNotRequested(),\r\n                titleHistory: requestedDecorations.includes(\"titleHistory\")\r\n                    ? getTitleHistoryForPerson(person)\r\n                    : lce_1.lceNotRequested(),\r\n                preferredPlatforms: (_a = data_validation_1.asOptionalArray(person.preferredPlatforms, data_validation_1.asString)) !== null && _a !== void 0 ? _a : [],\r\n                themeId: data_validation_1.asOptionalString(person.colorTheme),\r\n            };\r\n        }\r\n        catch (err) {\r\n            logger === null || logger === void 0 ? void 0 : logger.log(\"mapPersonToDomain\", logger_1.LogLevel.Warn, `Error mapping person for XUID ${person.xuid}, error: ${data_validation_1.toError(err).message}`);\r\n            return undefined;\r\n        }\r\n    }\r\n    else {\r\n        logger === null || logger === void 0 ? void 0 : logger.log(\"mapPersonToDomain\", logger_1.LogLevel.Warn, `Error mapping person for XUID ${person.xuid}`);\r\n        return undefined;\r\n    }\r\n}\r\nexports.mapPersonToDomain = mapPersonToDomain;\r\n/**\r\n * Transforms a raw PeopleHub response into a Map of XUIDs to `XboxProfileDataModel` objects,\r\n * or undefined for any XUIDs that were not successfully hydrated.\r\n *\r\n * Malformed people payloads will result in an error.\r\n *\r\n * @param raw The raw response from the service\r\n * @param requestedDecorations The decorations we expect to find on the response\r\n * @param logger Captures anomalies\r\n */\r\nfunction mapResponseToMap(raw, requestedDecorations, logger) {\r\n    const response = new Map();\r\n    const people = data_validation_1.asOptionalArray(raw === null || raw === void 0 ? void 0 : raw.people);\r\n    if (!people) {\r\n        return response;\r\n    }\r\n    for (const person of people) {\r\n        if (person.xuid) {\r\n            response.set(person.xuid, mapPersonToDomain(person, requestedDecorations, logger));\r\n        }\r\n    }\r\n    return response;\r\n}\r\nexports.mapResponseToMap = mapResponseToMap;\r\n/**\r\n * Transforms a raw PeopleHub response into an array of `XboxProfileDataModel` objects.\r\n *\r\n * People that were not successfully hydrated will be omitted. Malformed people payloads will result in an error.\r\n *\r\n * @param raw The raw response from the service\r\n * @param requestedDecorations The decorations we expect to find on the response\r\n * @param logger Captures anomalies\r\n */\r\nfunction mapResponseToArray(raw, requestedDecorations, logger) {\r\n    const results = [];\r\n    const people = data_validation_1.asOptionalArray(raw === null || raw === void 0 ? void 0 : raw.people);\r\n    if (!people) {\r\n        return results;\r\n    }\r\n    for (const rawPerson of people) {\r\n        const person = mapPersonToDomain(rawPerson, requestedDecorations, logger);\r\n        if (person) {\r\n            results.push(person);\r\n        }\r\n    }\r\n    return results;\r\n}\r\nexports.mapResponseToArray = mapResponseToArray;\r\n/**\r\n * Transforms a platforms manifest and its associated platforms localized\r\n * manifest to the type ApprovedPlatformData\r\n */\r\nfunction mapPlatformManifestToApprovedPlatformData(platformManifest, localizationManifest) {\r\n    const approvedPlatformData = [];\r\n    const resolvedPlatformResponse = data_validation_1.asObject(platformManifest);\r\n    const resolvedLocalizationResponse = data_validation_1.asObject(localizationManifest);\r\n    const contentManifests = data_validation_1.asArray(resolvedPlatformResponse.contentManifest);\r\n    contentManifests.forEach((manifest) => {\r\n        try {\r\n            const platformDescription = data_validation_1.asString(resolvedLocalizationResponse.localizedStrings.find((localeManifestItem) => localeManifestItem.id === manifest.id).description);\r\n            approvedPlatformData.push({\r\n                id: data_validation_1.asString(manifest.id),\r\n                icon: data_validation_1.asString(manifest.icon),\r\n                iconPath: data_validation_1.asString(manifest.iconPath),\r\n                description: platformDescription,\r\n            });\r\n        }\r\n        catch (err) {\r\n            return;\r\n        }\r\n    });\r\n    return approvedPlatformData;\r\n}\r\nexports.mapPlatformManifestToApprovedPlatformData = mapPlatformManifestToApprovedPlatformData;\r\n/**\r\n * Transforms a fetched themes manifest to the type ProfileThemeData for storage in our state.\r\n */\r\nfunction mapThemesManifestResponse(themesManifest, logger) {\r\n    const profileThemes = {};\r\n    for (const themeId of Object.keys(data_validation_1.asObject(themesManifest.themes))) {\r\n        try {\r\n            profileThemes[themeId] = data_validation_1.asObjectWithSchema(themesManifest.themes[themeId], {\r\n                id: () => themeId,\r\n                name: data_validation_1.asString,\r\n                iconUrl: data_validation_1.asString,\r\n                backgroundUrl: data_validation_1.asOptionalString,\r\n                cardUrl: data_validation_1.asOptionalString,\r\n            });\r\n        }\r\n        catch (e) {\r\n            logger === null || logger === void 0 ? void 0 : logger.log(\"mapThemesManifestResponse\", logger_1.LogLevel.Warn, `Error mapping theme with ID ${themeId}, error: ${data_validation_1.toError(e).message}`);\r\n        }\r\n    }\r\n    const categories = data_validation_1.asCompactArray(themesManifest.categories, (categoryManifest) => data_validation_1.asObjectWithSchema(categoryManifest, {\r\n        id: data_validation_1.asString,\r\n        name: data_validation_1.asString,\r\n        themeIds: (themeIds) => data_validation_1.asCompactArray(themeIds, (id) => {\r\n            // Drop any theme IDs which don't map to theme definitions that we resolved above\r\n            const themeId = data_validation_1.asString(id);\r\n            if (!profileThemes[themeId]) {\r\n                logger === null || logger === void 0 ? void 0 : logger.log(\"mapThemesManifestResponse\", logger_1.LogLevel.Warn, `Category contains invalid theme ID: ${themeId}`);\r\n                return null;\r\n            }\r\n  